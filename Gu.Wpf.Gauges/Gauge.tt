<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
namespace Gu.Wpf.Gauges
{
    using System.ComponentModel;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Media;

    [DefaultEvent(nameof(ValueChanged))]
    [DefaultProperty("Value")]
    public partial class Gauge
    {
<#
    var properties = new[]
                     {
                         new PropertyMetaData("Value", "double", "double.NaN", true),
                         new PropertyMetaData("Minimum", "double", "0.0d", true),
                         new PropertyMetaData("Maximum", "double", "10.0d", true),
                         new PropertyMetaData("IsDirectionReversed", "bool", null, true),
                         new PropertyMetaData("MajorTickFrequency", "double", null),
                         new PropertyMetaData("MajorTicks", "DoubleCollection", null),
                         new PropertyMetaData("MinorTickFrequency", "double", null),
                         new PropertyMetaData("MinorTicks", "DoubleCollection", null),
                         new PropertyMetaData("TextOrientation", "TextOrientation", "TextOrientation.Horizontal"),
                     };

    foreach (var property in properties)
    {
        var notifyOnChange = property.NotifyOnChange
            ? $@",
                On{property.Name}Changed"
            : string.Empty;
        WriteLineIfNotFirst(property, properties);
    #>
        public static readonly DependencyProperty <#= property.Name #>Property = DependencyProperty.RegisterAttached(
            nameof(<#= property.Name #>),
            typeof(<#= property.Type #>),
            typeof(Gauge),
            new FrameworkPropertyMetadata(
                <#= property.DefaultValue #>,
                FrameworkPropertyMetadataOptions.Inherits<#= notifyOnChange #>));
<#    } #>
<#  foreach (var property in properties)
    { #>

        public <#= property.Type #> <#= property.Name #>
        {
            get => (<#= property.Type #>)this.GetValue(<#= property.Name #>Property);
            set => this.SetValue(<#= property.Name #>Property, value);
        }
<#    } #>
<#  foreach (var property in properties)
    { #>

        public static void Set<#= property.Name #>(DependencyObject element, <#= property.Type #> value)
        {
            element.SetValue(<#= property.Name #>Property, value);
        }

        public static <#= property.Type #> Get<#= property.Name #>(DependencyObject element)
        {
            return (<#= property.Type #>)element.GetValue(<#= property.Name #>Property);
        }
<#    } #>
<#  foreach (var property in properties.Where(p => p.NotifyOnChange))
    { #>

        private static void On<#= property.Name #>Changed(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            if (d is Gauge gauge)
            {
                gauge.On<#= property.Name #>Changed((<#= property.Type #>)e.OldValue, (<#= property.Type #>)e.NewValue);
            }
        }
<#  } #>
    }
}
<#+

private void WriteLineIfNotFirst<T>(T item, IEnumerable<T> items)
{
    if (!ReferenceEquals(items.First(), item))
    {
        this.WriteLine("");
    }
}

public class PropertyMetaData
{
    public PropertyMetaData(string name, string type, string defaultValue, bool notifyOnChange = false)
    {
        Name = name;
        Type = type;
        DefaultValue = defaultValue ?? $"default({type})";
        NotifyOnChange = notifyOnChange;
    }

    public string Name { get; }

    public string Type { get; }

    public string DefaultValue { get; }

    public bool NotifyOnChange { get; }
}
#>
